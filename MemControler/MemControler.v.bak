`include "Ram.v"
module MemControler(

		input	 		clock, 
		input 			reset, 

		//Fetch 
		input 			if_mc_en,
		input 		[17:0] 	if_mc_addr, 
		output reg	[31:0]	mc_if_data, 

		//Memory 
		input 			mem_mc_rw, 
		input 			mem_mc_en, 
		input 		[17:0]	mem_mc_addr, 
		inout		[31:0]	mem_mc_data, 

		//Ram 
		output 	reg	[17:0]	mc_ram_addr, 
		output 			mc_ram_wre, 
		inout   	[15:0]	mc_ram_data

);

		reg  counter = 1'b0;

	assign mc_ram_wre = ((!mem_mc_en & if_mc_en) | !mem_mc_rw);
	assign mc_ram_data = (reset && (~mem_mc_rw)) ? mem_mc_data : 16'hzzzz;
	
	always @(posedge clock or  negedge reset) begin

		if(reset == 1'b0)begin

			mc_if_data <= 32'h0;
			mc_ram_addr <= 18'h0;
			

		end

		else begin

			if (mc_ram_wre) begin 
				

				if (mem_mc_rw == 1'b1)begin // write on memory
					//escrita em dois estÃ¡gios

					if (counter == 1'b0) begin

						mc_ram_addr <= mem_mc_addr >> 1 ;
			
					end				
				
					else begin

						mc_ram_addr <= (mem_mc_addr >> 1) + 1;
		
					end		
				end
				
				else if ( mem_mc_en == 1'b0 && if_mc_en == 1'b1) begin //fetch time
				
					if (counter == 1'b0)begin 
					
						mc_ram_addr <=  if_mc_addr>>1 ;
						mc_if_data[31:16] <= mc_ram_data;//parte mais significativa
											
					end

					else begin 

						mc_ram_addr <= (if_mc_addr>>1) + 1;
						mc_if_data [15:0] <= mc_ram_data;//parte menos significativa
	
					end 			
				end	
				counter <= counter + 1'b1;	
			end
		end
	end
	Ram ram_module ( .addr(mc_ram_addr), .data(mc_ram_data), .wre(mc_ram_wre), .oute(mem_mc_rw), .hb_mask(counter),.lb_mask(!counter),.chip_en(mem_mc_en));
endmodule
